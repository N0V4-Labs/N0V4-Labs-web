<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="How PHALANX's ECS is built on Flecs and EntityManager to handle tens of thousands of entities per frame.">
  <title>Inside PHALANX's ECS: Wrapping Flecs for 90k Entities</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Merriweather:ital,wght@0,300;0,400;0,700;0,900;1,400&family=Montserrat:wght@400;700;900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
<header>
  <nav class="navbar">
    <div class="container">
      <div class="nav-brand">
        <h1><a href="index.html" style="color: inherit; text-decoration: none;">ziX Performance Labs</a></h1>
      </div>
      <ul class="nav-menu">
        <li><a href="about.html">About</a></li>
      </ul>
    </div>
  </nav>
</header>

<main>
  <div class="container">
    <section class="blog-content">
      <article class="blog-post">
        <h2>Inside PHALANX's ECS: Wrapping Flecs for 90k Entities</h2>
        <div class="meta">
          October 7th, 2025
        </div>
        <figure class="hero-image">
          <img src="Phalanx-World-Item.png"
               alt="PHALANX world environment concept art showing a futuristic power station in a desert landscape">
        </figure>
        <div class="content">
          <p>
            Here's something that happens very predictably once you try to ship a 144&nbsp;FPS game with a lot of
            moving parts:
          </p>
          <p>
            At first, the entity model is whatever is convenient. A few classes here, some pointers there, a map of
            IDs to objects, maybe some shared pointers for safety. It works in small tests. Profiling shows a bit
            of overhead, but nothing alarming.
          </p>
          <p>
            Then you turn on a real match: mechs, minions, projectiles, debris, particles, vision probes, and all
            the simulation glue that ties them together. Suddenly, "convenient" data layout becomes a frame-time
            tax. The cache miss pattern is inscrutable. Adding one more effect system or debug overlay makes the
            frame stutter in ways that are hard to reproduce.
          </p>
          <p>
            PHALANX's entity system exists so we do not have to find out how bad that can get.
          </p>
          <p>
            If you want to update tens of thousands of small pieces of state and maintain performance&nbsp;, you do not get to scatter
            them around the heap in whatever shape feels comfortable that day. You need a plan.
          </p>
          <p>
            In a typical PHALANX match the number of player-controlled mechs is small, but the total entity count
            is not. Minions, projectiles, debris, particles, temporary vision probes, and assorted bits of
            simulation state all coexist. Peaks in the neighborhood of <strong>90,000 live entities</strong> are not
            rare spikes; they are a design target. At the same time the total frame budget we are aiming for is sub 8&nbsp;ms.
          </p>
          <p>
            This post digs into how the entity system is structured on top of <code>Flecs 4</code>, why it is wrapped
            in <code>phalnx::ecs::EntityManager</code> rather than exposed directly, and what that buys in terms of
            performance and failure modes. The pattern is the same one we use elsewhere: write down the rules
            first, then write the code that has a chance of obeying them.
          </p>

          <h3>Numbers first</h3>
          <p>
            It's easy to say "we want something fast and scalable" and then stop there. That kind of requirement
            is hard to falsify. Instead, we write down a small table of operation-level targets. If we drift far outside these, something is wrong. The header for EntityManager encodes them explicitly.
          </p>

          <figure>
            <figcaption><strong>Table&nbsp;1: ECS operation performance targets (per entity)</strong></figcaption>
            <table>
              <thead>
              <tr>
                <th>Operation</th>
                <th>Target</th>
                <th>Critical (investigate)</th>
              </tr>
              </thead>
              <tbody>
              <tr>
                <td>Entity creation (full component set)</td>
                <td>&lt; 150&nbsp;ns</td>
                <td>&gt; 200&nbsp;ns</td>
              </tr>
              <tr>
                <td><code>GetComponentMut</code> (mutable component access)</td>
                <td>&lt; 25&nbsp;ns</td>
                <td>&gt; 50&nbsp;ns</td>
              </tr>
              <tr>
                <td><code>AddComponent</code> (archetype migration)</td>
                <td>&lt; 500&nbsp;ns</td>
                <td>&gt; 600&nbsp;ns</td>
              </tr>
              <tr>
                <td><code>RemoveComponent</code> (archetype migration)</td>
                <td>&lt; 550&nbsp;ns</td>
                <td>&gt; 650&nbsp;ns</td>
              </tr>
              <tr>
                <td><code>IsAlive()</code> (entity liveness check)</td>
                <td>&lt; 15&nbsp;ns</td>
                <td>&gt; 25&nbsp;ns</td>
              </tr>
              </tbody>
            </table>
          </figure>

          <p>
            These numbers come directly from the documentation in <code>entity_manager.h</code>. They are not
            promises about any possible hardware; they are expectations on the machines we care about.
          </p>
          <p>
            The point is that when we discuss a change we are not arguing about whether something "feels fast
            enough." We are arguing about whether it keeps <code>AddComponent</code> under roughly half a microsecond
            and <code>GetComponentMut</code> under a couple dozen nanoseconds. Profiling becomes regression detection.
          </p>

          <h3>Flecs under the hood, EntityManager in front</h3>
          <p>
            We use <code>Flecs 4</code> as the core ECS runtime. Flecs stores entities with identical
            component signatures contiguously in archetype tables and gives us an API for querying and updating
            those tables. It also supplies staging and multi-threaded system execution.
          </p>
          <p>
            Gameplay code does not talk to the Flecs world directly. Instead it goes through a wrapper:
            <code>phalnx::ecs::EntityManager</code>. The motivation is not that the Flecs API is unsafe; the goal
            is a small, well-documented surface that encodes the way we are willing to use it. The relevant part of the class looks like this:
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">File: include/phalnx/ecs/entity_manager.h</p>
            <pre class="article-code-text cpp">// File: include/phalnx/ecs/entity_manager.h

#pragma once

#include "phalnx/ecs/structural_change_batch.h"

#include &lt;cstdint&gt;
#include &lt;expected&gt;
#include &lt;type_traits&gt;

#include &lt;flecs.h&gt;

namespace phalnx::ecs {

using EntityID = flecs::entity_t;

enum class ECSError {
  EntityNotFound,   // ID is invalid or entity has been destroyed
  ComponentMissing  // Entity exists but lacks requested component
};

class EntityManager {
 public:
  // Non-copyable, non-movable (one Flecs world per manager)
  EntityManager();
  ~EntityManager();
  EntityManager(const EntityManager&amp;)            = delete;
  EntityManager&amp; operator=(const EntityManager&amp;) = delete;
  EntityManager(EntityManager&amp;&amp;)                 = delete;
  EntityManager&amp; operator=(EntityManager&amp;&amp;)      = delete;

  template &lt;typename... Components&gt;
  [[nodiscard]] EntityID CreateEntity(Components&amp;&amp;... components);

  void DestroyEntity(EntityID id);
  [[nodiscard]] bool IsAlive(EntityID id) const;

  template &lt;typename T&gt;
  [[nodiscard]] const T* GetComponent(EntityID id) const;

  template &lt;typename T&gt;
  [[nodiscard]] T* GetComponentMut(EntityID id);

  template &lt;typename T&gt;
  [[nodiscard]] std::expected&lt;const T*, ECSError&gt;
  TryGetComponent(EntityID id) const;

  template &lt;typename T&gt;
  [[nodiscard]] std::expected&lt;T*, ECSError&gt;
  TryGetComponentMut(EntityID id);

  template &lt;typename T&gt;
  [[nodiscard]] bool HasComponent(EntityID id) const;

  template &lt;typename T&gt;
  void AddComponent(EntityID id, T&amp;&amp; component);

  template &lt;typename T&gt;
  void RemoveComponent(EntityID id);

  template &lt;typename... Components, typename Func&gt;
  void Query(Func&amp;&amp; callback) const;

  template &lt;typename... Components, typename Func&gt;
  void QueryMut(Func&amp;&amp; callback);

  void SetThreadCount(uint32_t thread_count);

  [[nodiscard]] flecs::world&amp;       GetWorld();
  [[nodiscard]] const flecs::world&amp; GetWorld() const;

  [[nodiscard]] StructuralChangeBatch BeginStructuralChangeBatch();

 private:
  mutable flecs::world world_;
};

}  // namespace phalnx::ecs</pre>
          </div>

          <p>
            All of the gameplay-facing ECS operations go through this class. Internally it constructs
            <code>flecs::entity</code> handles as needed and calls <code>set</code>, <code>add</code>, <code>remove</code>, <code>destruct</code>, and so on.
            Externally the rest of the codebase only needs to know about <code>EntityID</code> and these methods.
          </p>
          <p>
            That gives us a few things:
          </p>
          <ul>
            <li>A single place to attach documentation, invariants, and best practices.</li>
            <li>A seam where we route all Flecs allocations through PHALNX's custom allocators via FlecsAllocatorBridge, not just "eventually".</li>
            <li>A hook for Tracy profiling (<code>ENTITY_MANAGER_ZONE_SCOPED</code>) that does not pollute gameplay code.</li>
            <li>A way to adjust threading behavior or even swap out Flecs without rewriting every system.</li>
          </ul>
          <p>
            The wrapper is not there to make Flecs safer. It is there to make the way we use Flecs explicit and reviewable.
          </p>

          <h3>Components as plain old data</h3>
          <p>
            Components in PHALANX are deliberately uninteresting. They live in <code>phalnx::ecs</code> and they are
            required to be trivially copyable. The core set looks like this:
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">File: include/phalnx/ecs/components.h</p>
            <pre class="article-code-text cpp">// File: include/phalnx/ecs/components.h

#pragma once

#include &lt;cstdint&gt;
#include &lt;type_traits&gt;

namespace phalnx::ecs {

struct Position {
  float x = 0.0f;
  float y = 0.0f;
  float z = 0.0f;
};

struct Velocity {
  float x = 0.0f;
  float y = 0.0f;
  float z = 0.0f;
};

struct Rotation {
  float x = 0.0f;
  float y = 0.0f;
  float z = 0.0f;
  float w = 1.0f;
};

struct Health {
  float current_hp = 0.0f;
  float max_hp     = 0.0f;
};

struct Energy {
  float current_energy = 0.0f;
  float max_energy     = 0.0f;
};

struct Team {
  std::uint32_t team_id = 0;
};

struct MechTag {};
struct MinionTag {};
struct ProjectileTag {};
struct StructureTag {};

// Size &amp; trait checks (build fails if someone bloats a component)
static_assert(std::is_trivially_copyable_v&lt;Position&gt;);
static_assert(std::is_trivially_copyable_v&lt;Velocity&gt;);
static_assert(std::is_trivially_copyable_v&lt;Rotation&gt;);
static_assert(std::is_trivially_copyable_v&lt;Health&gt;);
static_assert(std::is_trivially_copyable_v&lt;Energy&gt;);
static_assert(std::is_trivially_copyable_v&lt;Team&gt;);

static_assert(std::is_empty_v&lt;MechTag&gt;);
static_assert(std::is_empty_v&lt;MinionTag&gt;);
static_assert(std::is_empty_v&lt;ProjectileTag&gt;);
static_assert(std::is_empty_v&lt;StructureTag&gt;);

// Optional size checks (ensure predictable cache use)
static_assert(sizeof(Position)   == 12);
static_assert(sizeof(Velocity)   == 12);
static_assert(sizeof(Rotation)   == 16);
static_assert(sizeof(Health)     == 8);
static_assert(sizeof(Energy)     == 8);
static_assert(sizeof(Team)       == 4);

}  // namespace phalnx::ecs</pre>
          </div>

          <p>
            In other words: they are POD with explicit sizes and the build will fail if someone introduces padding or slips a <code>std::string</code> into a hot component. The default initializers just zero or identity-initialize fields; the shape is exactly as shown.
          </p>
          <p>
            On the side, there's a <code>ComponentRegistry</code> that records metadata for each type: a human-readable name, size, alignment, and a flag for "tag vs data". It's essentially:
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">File: include/phalnx/ecs/component_registry.h</p>
            <pre class="article-code-text cpp">// File: include/phalnx/ecs/component_registry.h

struct ComponentMetadata {
  const char*   name       = nullptr;
  std::size_t   size       = 0;
  std::size_t   alignment  = 0;
  bool          is_tag     = false;
};

class ComponentRegistry {
 public:
  static ComponentRegistry&amp; Instance();

  template &lt;typename T&gt;
  void RegisterType(const char* name, bool is_tag);

  template &lt;typename T&gt;
  [[nodiscard]] const ComponentMetadata* GetMetadata() const;

 private:
  std::unordered_map&lt;std::type_index, ComponentMetadata&gt; registry_;
};</pre>
          </div>

          <p>
            The runtime ECS code doesn't depend on this; <code>EntityManager</code> doesn't know the registry exists by design. That separation is intentional: the hot path doesn't pay for reflection, and the editor/debug path doesn't have to tunnel back through the ECS wrapper to get type information.
          </p>

          <h3>Entity IDs and the habit of checking liveness</h3>
          <p>
            <code>EntityID</code> is an alias for <code>flecs::entity_t</code>, which is a 64-bit value containing both an
            index and a generation counter. When an entity is destroyed and its slot is reused, the generation
            changes. That solves the basic "stale ID accidentally refers to a new object" problem.
          </p>
          <p>
            The common pattern looks like this:
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">C++</p>
            <pre class="article-code-text cpp">using namespace phalnx::ecs;

void ApplyDamage(EntityManager&amp; manager, EntityID target) {
  if (!manager.IsAlive(target)) {
    return;
  }

  if (auto* hp = manager.GetComponentMut&lt;Health&gt;(target)) {
    hp-&gt;current_hp -= 10.0f;
  }
}</pre>
          </div>

          <p>
            Internally, <code>IsAlive</code> constructs a <code>flecs::entity</code> from the ID and calls
            <code>entity.is_alive()</code>. In debug builds there is also a <code>VALIDATE_ENTITY_ID</code> macro that
            yells if you pass zero as an <code>EntityID</code>.
          </p>
          <p>
            The implementation is short and the cost is
            on the order of a few nanoseconds: a lookup followed by a bitset check in Flecs. That's cheap enough
            that you can afford to be conservative.
          </p>
          <p>
            The rule is: whenever code captures an <code>EntityID</code> and uses it later—after one or more
            frames, after network round-trips, after deferred execution—it should guard that use with
            <code>IsAlive</code>.
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">C++</p>
            <pre class="article-code-text cpp">using namespace phalnx::ecs;

void ScheduledDamage(EntityManager&amp; manager, EntityID target) {
  scheduler.ScheduleEvent(1.0f, [&amp;, target]() {
    if (!manager.IsAlive(target)) return;

    if (auto* health = manager.GetComponentMut&lt;Health&gt;(target)) {
      health-&gt;current_hp -= 10.0f;
    }
  });
}</pre>
          </div>

          <p>
            This doesn't prevent all possible races, but it does stop the most direct use-after-destroy bugs. The "always guard delayed uses with <code>IsAlive</code>" rule is enforced consistently; that's what keeps the failure modes boring.
          </p>

          <h3>Structural changes and batches</h3>
          <p>
            The pleasant part of an archetype ECS is iterating over tight arrays of components. The less pleasant
            part is changing which components an entity has. Adding a component moves the entity to a new table.
            Removing a component does the same. In both cases all pointers to that entity's components become
            invalid, including pointers to components you did not explicitly change.
          </p>
          <p>
            The <code>EntityManager</code> interface exposes this through <code>AddComponent</code>,
            <code>RemoveComponent</code>, and <code>DestroyEntity</code>. The comments on these functions are blunt about
            pointer invalidation and include small examples of what goes wrong if you ignore that fact.
          </p>
          <p>
            For a single entity, the safe pattern is:
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">C++</p>
            <pre class="article-code-text cpp">using namespace phalnx::ecs;

void PromoteEntity(EntityManager&amp; manager, EntityID entity) {
  // Get pointer before migration
  Position* pos = manager.GetComponentMut&lt;Position&gt;(entity);
  if (!pos) return;

  pos-&gt;x = 10.0f;

  // Structural change: archetype migration
  manager.AddComponent(entity, Energy{100.0f, 100.0f});

  // Re-query after migration (old pointer is now invalid)
  pos = manager.GetComponentMut&lt;Position&gt;(entity);
  if (!pos) return;

  pos-&gt;y = 20.0f;
}</pre>
          </div>

          <p>
            For bulk changes there is a separate tool: <code>StructuralChangeBatch</code>. This is a small RAII
            wrapper around <code>world.defer_begin()</code> / <code>world.defer_end()</code> on the underlying Flecs world. While it is alive, Flecs queues structural changes in a per-thread staging area. When it
            ends, those queued operations are applied atomically.
          </p>
          <p>
            Usage looks like this:
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">File: include/phalnx/ecs/structural_change_batch.h (usage example)</p>
            <pre class="article-code-text cpp">// File: include/phalnx/ecs/structural_change_batch.h (usage example)

using namespace phalnx::ecs;

void SpawnWave(EntityManager&amp; manager) {
  auto batch = manager.BeginStructuralChangeBatch();

  for (int i = 0; i &lt; 1000; ++i) {
    EntityID id = manager.CreateEntity();
    batch.AddComponent(id, Position{float(i), 0.0f, 0.0f});
    batch.AddComponent(id, Health{100.0f, 100.0f});
  }  // destructor calls defer_end(), applying queued changes
}</pre>
          </div>

          <p>
            From the code's point of view, batching gives two properties:
          </p>
          <ul>
            <li>An all-or-nothing boundary: either all of these structural changes become visible together or none of them do.</li>
            <li>A way to control when pointers go stale. Component pointers remain valid within the batch's scope; they are invalidated when the batch flushes.</li>
          </ul>
          <p>
            The <code>StructuralChangeBatch</code> class also has an <code>Apply()</code> method that explicitly calls <code>defer_end()</code> and then
            <code>defer_begin()</code> again, letting you flush mid-batch (for debugging or profiling) and then keep
            queuing more operations in the same scope.
          </p>
          <p>
            The important detail is that batching is there primarily for transaction-like semantics and pointer-invalidation control, not to make structural changes "free". You still pay for migrations when the batch flushes. The
            mental model should be "group these changes and make them appear all at once," not "structural
            changes are cheap now."
          </p>

          <h3>Queries as the iteration primitive</h3>
          <p>
            Most systems do not care about entity creation or destruction; they care about iterating over
            entities that have certain components. <code>EntityManager</code> exposes this via two templates:
            <code>Query</code> for read-only access and <code>QueryMut</code> for mutable access.
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">C++</p>
            <pre class="article-code-text cpp">using namespace phalnx::ecs;

void SampleReadOnlyQuery(const EntityManager&amp; manager) {
  manager.Query&lt;Position, const Velocity&gt;(
      [](EntityID id, const Position&amp; pos, const Velocity&amp; vel) {
        // read-only path
        (void)id;
        (void)pos;
        (void)vel;
      });
}

void IntegratePositions(EntityManager&amp; manager, float dt) {
  manager.QueryMut&lt;Position, const Velocity&gt;(
      [dt](EntityID id, Position&amp; pos, const Velocity&amp; vel) {
        (void)id;
        pos.x += vel.x * dt;
        pos.y += vel.y * dt;
        pos.z += vel.z * dt;
      });
}</pre>
          </div>

          <p>
            Under the hood, both forms construct a Flecs query and call <code>.each</code> with a lambda that
            receives a <code>flecs::entity</code> and component references; the wrapper converts
            <code>entity.id()</code> to an <code>EntityID</code> and forwards the component references.
          </p>
          <p>
            The const vs mutable distinction is enforced at the type level, so if you pick <code>Query</code> you cannot
            accidentally mutate components. Both methods also wrap the iteration in a Tracy profiler zone via
            <code>ENTITY_MANAGER_ZONE_SCOPED</code>, so query cost shows up cleanly in profiles.
          </p>
          <p>
            The performance target for these iterations is on the order of ~50&nbsp;ns per entity for common
            queries, which keeps a 20k-entity pass under roughly one millisecond. Archetype storage gives the
            usual benefit: entities with the same component sets are adjacent in memory, and the queries walk
            that memory linearly.
          </p>
          <p>
            This is also the point where we stop pretending entities are objects. Systems express "all entities with (Position, Velocity)" as a single pass, and the ECS layer makes that
            pattern cheap enough to use everywhere.
          </p>

          <h3>Threading: configuring Flecs, not replacing it</h3>
          <p>
            For threading, the wrapper provides <code>SetThreadCount</code>, which simply calls
            <code>world_.set_threads(...)</code> on the underlying Flecs world. Systems are then registered directly on
            that world.
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">C++</p>
            <pre class="article-code-text cpp">using namespace phalnx::ecs;

void ConfigureEcs(EntityManager&amp; manager, int hardware_threads) {
  // Reserve a few cores for render/audio/OS
  const uint32_t worker_threads = std::max(1, hardware_threads - 3);
  manager.SetThreadCount(worker_threads);

  auto&amp; world = manager.GetWorld();

  const float dt = 1.0f / 144.0f;

  world.system&lt;Position, const Velocity&gt;("ProjectilePhysics")
      .multi_threaded()
      .each([dt](flecs::entity e, Position&amp; pos, const Velocity&amp; vel) {
        (void)e;
        pos.x += vel.x * dt;
        pos.y += vel.y * dt;
        pos.z += vel.z * dt;
      });
}</pre>
          </div>

          <p>
            The pattern is straightforward:
          </p>
          <ul>
            <li>Configure the thread count once at initialization, before the main loop.</li>
            <li>Register systems on the main thread before the first call to <code>world.progress()</code>.</li>
            <li>Mark systems that can safely run in parallel with <code>.multi_threaded()</code>.</li>
            <li>Let Flecs handle slicing entity sets across worker threads.</li>
          </ul>
          <p>
            Structural changes that occur inside multi-threaded systems are automatically deferred to per-thread
            stages and merged at synchronization points when the world progresses. Reads of components are safe
            across threads during that window; writes are safe as long as each entity is only processed by one
            thread (which is exactly what Flecs arranges for these systems).
          </p>
          <p>
            The wrapper doesn't try to replace Flecs' threading model. It just gives us a predictable place to
            turn the dial and a documented set of constraints around it.
          </p>

          <h3>Memory: Flecs allocations on our terms</h3>
          <p>
            By default, Flecs would allocate via <code>malloc</code>/<code>free</code>, which is not the kind of variability you want in a 6.94&nbsp;ms frame budget. PHALANX replaces all Flecs internal allocations with our own memory subsystem via <code>phalnx::memory::FlecsAllocatorBridge</code>.
          </p>
          <p>
            The bridge routes allocations roughly as:
          </p>
          <ul>
            <li>0–256 bytes: thread-local FrameAllocator (via ThreadLocalAllocators) — zero contention.</li>
            <li>257–4096 bytes: SizeClassPoolAllocator with per-size-class mutexes.</li>
            <li>&gt;4096 bytes: FreeListAllocator with guarded free lists.</li>
          </ul>
          <p>
            There's a small header (<code>FlecsAllocationHeader</code>) prepended to each allocation so deallocation can route back to the correct allocator and record statistics for Tracy. The effect is to take Flecs' memory traffic and run it through structures whose performance characteristics we actually know.
          </p>
          <p>
            From the ECS article's point of view, this shows up as: "EntityManager's Flecs world doesn't allocate directly from the CRT." That's already true in the current codebase.
          </p>

          <h3>Error handling: null pointers and std::expected</h3>
          <p>
            The basic component accessors return either a pointer to the component or <code>nullptr</code>:
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">C++</p>
            <pre class="article-code-text cpp">using namespace phalnx::ecs;

void NudgeX(EntityManager&amp; manager, EntityID id) {
  if (auto* pos = manager.GetComponentMut&lt;Position&gt;(id)) {
    pos-&gt;x += 1.0f;
  }
}</pre>
          </div>

          <p>
            This is the cheap, hot path. It's good enough for most gameplay systems: either the component is
            there, or it is not, and "missing" is a normal condition.
          </p>
          <p>
            For situations where it matters why a lookup failed there are <code>TryGetComponent</code> and
            <code>TryGetComponentMut</code>, which wrap the pointer in <code>std::expected</code> and tag
            failures with <code>ECSError::EntityNotFound</code> or <code>ECSError::ComponentMissing</code>.
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">C++</p>
            <pre class="article-code-text cpp">using namespace phalnx::ecs;

void ApplyDirectDamage(EntityManager&amp; manager, EntityID id, float amount) {
  auto result = manager.TryGetComponentMut&lt;Health&gt;(id);

  if (!result) {
    switch (result.error()) {
      case ECSError::EntityNotFound:
        // entity is gone (ID invalid or destroyed)
        LOG_DEBUG(ECS, "Damage skipped: entity {} not found", id);
        return;

      case ECSError::ComponentMissing:
        // entity exists but does not have Health
        LOG_DEBUG(ECS, "Damage skipped: entity {} has no Health", id);
        return;
    }
  }

  result.value()-&gt;current_hp -= amount;
}</pre>
          </div>

          <p>
            Mechanically, this is just a thin layer over the same logic, but it gives code that cares about
            diagnostics a clearer path. A replay system can distinguish "this entity died" from "this entity
            never had that component." A debugging tool can log more precise messages instead of guessing.
          </p>
          <p>
            Most code paths do not need this level of detail and use the pointer-returning forms. The important
            bit is that the structured version exists and is spelled out in the API, not buried under
            <code>dynamic_cast</code> or exceptions.
          </p>

          <h3>Oh yeah: here is a T1 turret render</h3>
          <p>
            All of this is fairly abstract. It's about archetypes, liveness checks, pointer invalidation, and staged allocations. To make things more concrete, here is one of the assets this machinery exists to support: a
            render of our Tier&nbsp;1 outer turret design for PHALANX.
          </p>

          <figure>
            <img src="t1-outer-tower-v2-final-Rendered.png"
                 alt="Render of the Tier 1 outer turret design for PHALANX">
          </figure>

          <p>
            When the entity system behaves, you can have scenes full of objects like this — tracking targets,
            taking damage, respawning — without the simulation becoming the bottleneck. The ECS layer is there
            partly so we can afford to have many of these doing useful work at once without guessing where the
            time went or why a pointer suddenly went stale.
          </p>
          <p>
            The rules are simple:
          </p>
          <ul>
            <li>Keep components as POD with explicit sizes.</li>
            <li>Guard delayed uses with <code>IsAlive()</code>.</li>
            <li>Respect pointer invalidation on structural changes (and use <code>StructuralChangeBatch</code> when you want atomic visibility).</li>
            <li>Run everything through a thin wrapper that is honest about performance, memory, and failure modes.</li>
          </ul>
          <p>
            The rest — 90k entities, 144&nbsp;FPS, and a field of active turrets — is just what happens when those rules are obeyed consistently.
          </p>
        </div>
      </article>
    </section>
  </div>
</main>

<footer>
  <div class="container">
    <p>
      <a href="https://github.com/N0V4-Labs" style="color: var(--link-color); text-decoration: none;">github</a>
      &nbsp;•&nbsp;
      <a href="about.html" style="color: var(--link-color); text-decoration: none;">about</a>
    </p>
  </div>
</footer>
</body>
</html>
