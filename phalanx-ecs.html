<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="How PHALANX's ECS is built on Flecs and EntityManager to handle tens of thousands of entities per frame.">
  <title>Inside PHALANX’s ECS: Wrapping Flecs for 90k Entities</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Merriweather:ital,wght@0,300;0,400;0,700;0,900;1,400&family=Montserrat:wght@400;700;900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
<header>
  <nav class="navbar">
    <div class="container">
      <div class="nav-brand">
        <h1><a href="index.html" style="color: inherit; text-decoration: none;">ziX Performance Labs</a></h1>
      </div>
      <ul class="nav-menu">
        <li><a href="about.html">About</a></li>
      </ul>
    </div>
  </nav>
</header>

<main>
  <div class="container">
    <section class="blog-content">
      <article class="blog-post">
        <h2>Inside PHALANX’s ECS: Wrapping Flecs for 90k Entities</h2>
        <div class="meta">
          November 25, 2025
        </div>
        <div class="content">
          <p>
            The entity system in PHALANX exists for a fairly ordinary reason: recent hardware is fast, but not
            fast enough to forgive arbitrary decisions about data layout. If you want to update tens of thousands
            of small pieces of state at 144&nbsp;Hz, you do not get to scatter them around the heap in whatever
            shape feels convenient that day. You need a plan.
          </p>
          <p>
            In a typical PHALANX match the number of player-controlled mechs is small, but the total entity count
            is not. Minions, projectiles, debris, particles, temporary vision probes, and assorted bits of
            simulation state all coexist. Peaks in the neighborhood of <strong>90,000 live entities</strong> are not
            exotic corner cases; they are a design target. At the same time the total frame budget is
            6.94&nbsp;ms if you want to hit 144&nbsp;FPS.
          </p>
          <p>
            This post digs into how the entity system is structured on top of <code>Flecs 4.x</code>, why it is wrapped
            in <code>phalnx::ecs::EntityManager</code> rather than exposed directly, and what that buys in terms of
            performance and failure modes. The pattern is similar to the spinlock examples: write down the rules
            first, then write the code that has a chance of obeying them.
          </p>

          <h3>Numbers first</h3>
          <p>
            It is easy to say “we want something fast and scalable” and then stop there. That kind of requirement
            is hard to falsify. Instead, for PHALANX the ECS layer has a small table of operation-level targets.
            If we drift far outside of these, something is wrong.
          </p>

          <figure>
            <figcaption><strong>Table&nbsp;1: ECS operation targets in PHALANX</strong></figcaption>
            <table>
              <thead>
              <tr>
                <th>Operation</th>
                <th>Target</th>
                <th>Critical</th>
              </tr>
              </thead>
              <tbody>
              <tr>
                <td>Entity creation (full component set)</td>
                <td>&lt; 150&nbsp;ns</td>
                <td>&gt; 200&nbsp;ns</td>
              </tr>
              <tr>
                <td><code>GetComponentMut</code> (in-place write)</td>
                <td>&lt; 25&nbsp;ns</td>
                <td>&gt; 50&nbsp;ns</td>
              </tr>
              <tr>
                <td><code>AddComponent</code> (archetype migration)</td>
                <td>&lt; 500&nbsp;ns</td>
                <td>&gt; 600&nbsp;ns</td>
              </tr>
              <tr>
                <td><code>RemoveComponent</code> (archetype migration)</td>
                <td>&lt; 550&nbsp;ns</td>
                <td>&gt; 650&nbsp;ns</td>
              </tr>
              <tr>
                <td><code>IsAlive()</code> liveness check</td>
                <td>&lt; 15&nbsp;ns</td>
                <td>&gt; 25&nbsp;ns</td>
              </tr>
              </tbody>
            </table>
          </figure>

          <p>
            These numbers come directly from the header comments in <code>entity_manager.h</code>. They are not
            promises about any possible hardware; they are expectations on the machines we care about. The point
            is that when we discuss a change we are not arguing about whether something “feels fast enough” but
            about whether it keeps <code>AddComponent</code> under roughly half a microsecond and
            <code>GetComponentMut</code> under a couple of dozen nanoseconds.
          </p>

          <h3>Flecs under the hood, EntityManager in front</h3>
          <p>
            PHALANX uses <code>Flecs 4.x</code> as the core ECS runtime. Flecs stores entities with identical
            component signatures contiguously in archetype tables and gives you an API for querying and updating
            those tables. It also supplies a staging system and multi-threaded system execution.
          </p>
          <p>
            Gameplay code does not talk to the Flecs world directly. Instead it goes through a wrapper:
            <code>phalnx::ecs::EntityManager</code>. The motivation is not that the Flecs API is unsafe; the goal
            is to have a small, well-documented surface that encodes the way we are willing to use it.
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">entity_manager.h</p>
            <pre class="article-code-text cpp">using EntityID = flecs::entity_t;

enum class ECSError {
  EntityNotFound,
  ComponentMissing
};

class EntityManager {
public:
  template&lt;typename... Components&gt;
  [[nodiscard]] EntityID CreateEntity(Components&amp;&amp;... components);

  void DestroyEntity(EntityID id);
  [[nodiscard]] bool IsAlive(EntityID id) const;

  template&lt;typename T&gt;
  [[nodiscard]] const T* GetComponent(EntityID id) const;

  template&lt;typename T&gt;
  [[nodiscard]] T* GetComponentMut(EntityID id);

  template&lt;typename T&gt;
  [[nodiscard]] std::expected&lt;const T*, ECSError&gt;
    TryGetComponent(EntityID id) const;

  template&lt;typename T&gt;
  [[nodiscard]] std::expected&lt;T*, ECSError&gt;
    TryGetComponentMut(EntityID id);

  template&lt;typename T&gt;
  [[nodiscard]] bool HasComponent(EntityID id) const;

  template&lt;typename T&gt;
  void AddComponent(EntityID id, T&amp;&amp; component);

  template&lt;typename T&gt;
  void RemoveComponent(EntityID id);

  template&lt;typename... Components, typename Func&gt;
  void Query(Func&amp;&amp; callback) const;

  template&lt;typename... Components, typename Func&gt;
  void QueryMut(Func&amp;&amp; callback);

  void SetThreadCount(std::uint32_t thread_count);

  [[nodiscard]] flecs::world&amp;       GetWorld();
  [[nodiscard]] const flecs::world&amp; GetWorld() const;

  [[nodiscard]] StructuralChangeBatch BeginStructuralChangeBatch();

private:
  mutable flecs::world world_;
};</pre>
          </div>

          <p>
            All of the gameplay-facing ECS operations go through this class. Internally it constructs
            <code>flecs::entity</code> handles as needed and calls <code>set</code>, <code>add</code>, <code>remove</code>, <code>destruct</code>, and so on.
            Externally the rest of the codebase only needs to know about <code>EntityID</code> and these methods.
            That gives us a place to attach documentation, to route allocations through custom allocators over
            time, to integrate profiling, and to adjust threading behavior without rewriting every system.
          </p>

          <h3>Components as plain old data</h3>
          <p>
            Components in PHALANX are deliberately uninteresting. They live in <code>phalnx::ecs</code> and they are
            required to be trivially copyable. The core set looks like this:
          </p>

          <div class="code-block">
<pre><code>struct Position  { float x, y, z; };
struct Velocity  { float x, y, z; };
struct Rotation  { float x, y, z, w; };

struct Health    { float current_hp, max_hp; };
struct Energy    { float current_energy, max_energy; };
struct Team      { std::uint32_t team_id; };

struct MechTag      {};
struct MinionTag    {};
struct ProjectileTag{};
struct StructureTag {};</code></pre>
          </div>

          <p>
            In the actual header these components have sensible default initializers, but the shape is exactly
            this. The header file <code>components.h</code> asserts that these are trivially copyable and that their
            sizes are exactly what we expect: <code>Position</code> and <code>Velocity</code> are 12&nbsp;bytes each,
            <code>Rotation</code> is 16, <code>Health</code> and <code>Energy</code> are 8, <code>Team</code> is 4, and the tag types are
            empty. There are also <code>static_assert</code> checks that the tag components are
            <code>std::is_empty_v&lt;T&gt;</code>. These constraints are not deep; they are there to prevent accidental
            padding and to keep common archetypes within predictable cache-line budgets.
          </p>
          <p>
            On the side, there is a <code>ComponentRegistry</code> that records metadata for each type:
            a human-readable name, the size, the alignment, and whether it is a tag. This registry is a simple
            <code>std::unordered_map&lt;std::type_index, ComponentMetadata&gt;</code> and is used for logging, serialization,
            and tooling. The runtime ECS code does not depend on it; <code>EntityManager</code> does not know the
            registry exists, by design.
          </p>

          <h3>Entity IDs and the habit of checking liveness</h3>
          <p>
            <code>EntityID</code> is an alias for <code>flecs::entity_t</code>, which is a 64-bit value containing both an
            index and a generation counter. When an entity is destroyed and its slot is reused, the generation
            changes. That solves the basic “stale ID accidentally refers to a new object” problem.
          </p>
          <p>
            The liveness check looks like this:
          </p>

          <div class="code-block">
<pre><code>if (manager.IsAlive(target)) {
  if (auto* hp = manager.GetComponentMut&lt;Health&gt;(target)) {
    hp-&gt;current_hp -= 10.0f;
  }
}</code></pre>
          </div>

          <p>
            Internally <code>IsAlive</code> constructs a <code>flecs::entity</code> from the ID and calls
            <code>entity.is_alive()</code>. In debug builds there is also a <code>VALIDATE_ENTITY_ID</code> macro that
            prints a warning if you pass zero as an <code>EntityID</code>. The implementation is short and the cost is
            on the order of a few nanoseconds: a lookup followed by a bitset check in Flecs.
          </p>
          <p>
            The pattern we want here is similar to the one in the spinlock example where you use <code>READ_ONCE</code>
            at the right points. Whenever code captures an <code>EntityID</code> and uses it later—after one or more
            frames, after network round-trips, after deferred execution—it should guard uses with
            <code>IsAlive</code>. That does not prevent races, but it does stop the most direct use-after-destroy bugs.
          </p>

          <div class="code-block">
<pre><code>void ScheduledDamage(EntityID target) {
  scheduler.ScheduleEvent(1.0f, [&, target]() {
    if (!manager.IsAlive(target)) return;

    if (auto* health = manager.GetComponentMut&lt;Health&gt;(target)) {
      health-&gt;current_hp -= 10.0f;
    }
  });
}</code></pre>
          </div>

          <p>
            In terms of cost, the liveness check is cheap enough that this pattern is preferable to any scheme
            that assumes entity IDs stay valid forever and then tries to debug the consequences later.
          </p>

          <h3>Structural changes and batches</h3>
          <p>
            The pleasant part of an archetype ECS is iterating over tight arrays of components. The less pleasant
            part is changing which components an entity has. Adding a component moves the entity to a new table.
            Removing a component does the same. In both cases all pointers to that entity’s components become
            invalid, including pointers to components you did not explicitly change.
          </p>
          <p>
            The <code>EntityManager</code> interface exposes this through <code>AddComponent</code>,
            <code>RemoveComponent</code>, and <code>DestroyEntity</code>. The comments on these functions are blunt about
            pointer invalidation, and they include minimal examples of what goes wrong if you ignore that fact.
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">structural_changes.cpp</p>
            <pre class="article-code-text cpp">// Danger: AddComponent invalidates all component pointers.
Position* pos = manager.GetComponentMut&lt;Position&gt;(entity);
pos-&gt;x = 10.0f;
manager.AddComponent(entity, Energy{100.0f, 100.0f}); // archetype migration
pos-&gt;y = 20.0f; // undefined behavior: pos is now dangling</pre>
          </div>

          <p>
            The safe pattern for single entities is to re-query after a structural change:
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">structural_changes.cpp</p>
            <pre class="article-code-text cpp">Position* pos = manager.GetComponentMut&lt;Position&gt;(entity);
pos-&gt;x = 10.0f;
manager.AddComponent(entity, Energy{100.0f, 100.0f});
pos = manager.GetComponentMut&lt;Position&gt;(entity); // fresh pointer
pos-&gt;y = 20.0f;</pre>
          </div>

          <p>
            For bulk changes there is a separate tool: <code>StructuralChangeBatch</code>. This is a small RAII
            wrapper that calls <code>world.defer_begin()</code> in its constructor and <code>world.defer_end()</code> in its
            destructor. While it is alive, Flecs queues structural changes in a per-thread staging area. When it
            ends, those queued operations are applied.
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">structural_changes.cpp</p>
            <pre class="article-code-text cpp">auto batch = manager.BeginStructuralChangeBatch();

for (int i = 0; i &lt; 1000; ++i) {
  EntityID id = manager.CreateEntity();
  batch.AddComponent(id, Position{float(i), 0.0f, 0.0f});
  batch.AddComponent(id, Health{100.0f, 100.0f});
} // destructor calls defer_end(), applying queued changes</pre>
          </div>

          <p>
            From the code’s point of view this gives two properties. First, it provides an all-or-nothing
            boundary: either all of these structural changes become visible together or none of them do. Second,
            it reduces the number of places where pointer invalidation can occur. Pointers remain valid within
            the batch scope; they are invalidated when the batch flushes.
          </p>
          <p>
            The batch class also has an <code>Apply</code> method that explicitly calls <code>defer_end</code> and then
            <code>defer_begin</code> again. This lets you flush mid-batch for debugging or profiling and then keep
            queuing more operations within the same scope.
          </p>
          <p>
            The important detail is that batching is there primarily for transaction-like semantics and for
            controlling when pointers go stale. You still pay for structural changes when the batch flushes, but
            the mental model should be “group these changes and make them appear all at once,” not “structural
            changes are free now.” In practice the expectation is that you stay within the per-operation budgets
            from Table&nbsp;1 while getting better behavior and, for large bulk spawns, a noticeable speedup.
          </p>

          <h3>Queries as the iteration primitive</h3>
          <p>
            Most systems do not care about entity creation or destruction; they care about iterating over
            entities that have certain components. The <code>EntityManager</code> exposes this via two templates:
            <code>Query</code> for read-only access and <code>QueryMut</code> for mutable access.
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">queries.cpp</p>
            <pre class="article-code-text cpp">manager.Query&lt;Position, const Velocity&gt;(
  [](EntityID id, const Position&amp; pos, const Velocity&amp; vel) {
    // read-only path
  });

float dt = 0.016f;
manager.QueryMut&lt;Position, const Velocity&gt;(
  [dt](EntityID id, Position&amp; pos, const Velocity&amp; vel) {
    pos.x += vel.x * dt;
    pos.y += vel.y * dt;
    pos.z += vel.z * dt;
  });</pre>
          </div>

          <p>
            Under the hood both forms construct a Flecs query and call <code>.each</code> with a lambda that
            receives a <code>flecs::entity</code> and component references. The wrapper converts
            <code>entity.id()</code> to an <code>EntityID</code> and forwards the component references. The const vs
            mutable distinction is enforced at the type level, so if you pick <code>Query</code> you cannot
            accidentally mutate components. Both methods also wrap the iteration in a Tracy profiler zone via
            <code>ENTITY_MANAGER_ZONE_SCOPED</code>, so query cost shows up cleanly in profiles.
          </p>
          <p>
            The performance target for these iterations is on the order of 50&nbsp;ns per entity for common
            queries, which keeps a 20k-entity pass under roughly one millisecond. Archetype storage gives the
            usual benefit: entities with the same component sets are adjacent in memory, and the queries walk
            that memory linearly.
          </p>

          <h3>Threading: configuring Flecs, not replacing it</h3>
          <p>
            For threading, the wrapper provides a <code>SetThreadCount</code> method that calls
            <code>world.set_threads</code> on the underlying Flecs world. Systems are then registered directly on
            that world.
          </p>

          <div class="code-block">
<pre><code>EntityManager manager;
manager.SetThreadCount(13); // example on a 16-core machine

auto&amp; world = manager.GetWorld();

world.system&lt;Position, const Velocity&gt;("ProjectilePhysics")
  .multi_threaded()
  .each([](flecs::entity e, Position&amp; pos, const Velocity&amp; vel) {
    pos.x += vel.x * dt;
    pos.y += vel.y * dt;
    pos.z += vel.z * dt;
  });</code></pre>
          </div>

          <p>
            The recommended pattern is straightforward: configure the thread count once at initialization, register
            systems on the main thread before the main loop begins, and then let Flecs handle slicing entity sets
            across worker threads for systems marked <code>.multi_threaded()</code>. Structural changes that occur
            inside those systems are automatically deferred to per-thread stages and merged at synchronization
            points when the world progresses.
          </p>

          <h3>Error handling: null pointers and expected errors</h3>
          <p>
            The basic component accessors return either a pointer to the component or <code>nullptr</code>:
          </p>

          <div class="code-block">
<pre><code>if (auto* pos = manager.GetComponentMut&lt;Position&gt;(id)) {
  pos-&gt;x += 1.0f;
}</code></pre>
          </div>

          <p>
            For situations where it matters why a lookup failed there are the <code>TryGetComponent</code> and
            <code>TryGetComponentMut</code> variants, which wrap the pointer in <code>std::expected</code> and tag
            failures with <code>ECSError::EntityNotFound</code> or <code>ECSError::ComponentMissing</code>. This is
            mechanically just a thin layer over the same logic, but it gives code that cares about diagnostics a
            clearer path.
          </p>

          <div class="code-block">
<pre><code>enum class ECSError {
  EntityNotFound,
  ComponentMissing
};

auto result = manager.TryGetComponentMut&lt;Health&gt;(id);
if (!result) {
  if (result.error() == ECSError::EntityNotFound) {
    // entity is gone
  } else {
    // entity exists but lacks Health
  }
} else {
  result.value()-&gt;current_hp -= 25.0f;
}</code></pre>
          </div>

          <p>
            Most code paths do not need this level of detail and use the pointer-returning forms. When you are
            implementing something like a replay system, though, it is useful to know whether you are looking at
            a dead entity or at an entity that never had the component in the first place.
          </p>

          <h3>Oh yeah: here is a T1 turret render</h3>
          <p>
            All of this is fairly abstract. It is about archetypes, liveness checks, and avoiding use-after-free
            bugs. To make things more concrete, here is one of the assets this machinery exists to support: a
            render of our Tier&nbsp;1 outer turret design for PHALANX.
          </p>
          <p>
            When the entity system behaves, you can have scenes full of objects like this—tracking targets,
            taking damage, respawning—without the simulation becoming the bottleneck.
          </p>

          <figure>
            <img src="t1-outer-tower-v2-final-Rendered.png"
                 alt="Render of the Tier 1 outer turret design for PHALANX"
                 style="max-width: 100%; height: auto; border-radius: 4px;">
            <figcaption>
              Tier&nbsp;1 outer turret in PHALANX. The ECS layer exists partly so that we can afford to
              have many of these doing useful work at once.
            </figcaption>
          </figure>
        </div>
      </article>
    </section>
  </div>
</main>

<footer>
  <div class="container">
    <p>
      <a href="https://github.com/N0V4-Labs" style="color: var(--link-color); text-decoration: none;">github</a>
      &nbsp;•&nbsp;
      <a href="about.html" style="color: var(--link-color); text-decoration: none;">about</a>
    </p>
  </div>
</footer>
</body>
</html>
