<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="How PHALANX's ECS is built on Flecs and EntityManager to handle tens of thousands of entities per frame.">
  <title>Inside PHALANX’s ECS: Wrapping Flecs for 90k Entities</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Merriweather:ital,wght@0,300;0,400;0,700;0,900;1,400&family=Montserrat:wght@400;700;900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
<header>
  <nav class="navbar">
    <div class="container">
      <div class="nav-brand">
        <h1><a href="index.html" style="color: inherit; text-decoration: none;">ziX Performance Labs</a></h1>
      </div>
      <ul class="nav-menu">
        <li><a href="about.html">About</a></li>
      </ul>
    </div>
  </nav>
</header>

<main>
  <div class="container">
    <section class="blog-content">
      <article class="blog-post">
        <h2>Inside PHALANX’s ECS: Wrapping Flecs for 90k Entities</h2>
        <div class="meta">
          November 25, 2025
        </div>
        <div class="content">
          <p>
            Here is something that happens very predictably once you try to ship a 144&nbsp;FPS game with a lot of
            moving parts:
          </p>
          <p>
            At first, the entity model is whatever is convenient. A few classes here, some pointers there, a map of
            IDs to objects, maybe some shared pointers for safety. It works in small tests. Profiling shows a bit
            of overhead, but nothing alarming.
          </p>
          <p>
            Then you turn on a real match: mechs, minions, projectiles, debris, particles, vision probes, and all
            the simulation glue that ties them together. Suddenly, "convenient" data layout becomes a frame-time
            tax. The cache miss pattern is inscrutable. Adding one more effect system or debug overlay makes the
            frame stutter in ways that are hard to reproduce.
          </p>
          <p>
            PHALANX's entity system exists so we do not have to find out how bad that can get.
          </p>
          <p>
            If you want to update tens of thousands of small pieces of state at 144&nbsp;Hz, you do not get to scatter
            them around the heap in whatever shape feels comfortable that day. You need a plan.
          </p>
          <p>
            In a typical PHALANX match the number of player-controlled mechs is small, but the total entity count
            is not. Minions, projectiles, debris, particles, temporary vision probes, and assorted bits of
            simulation state all coexist. Peaks in the neighborhood of <strong>90,000 live entities</strong> are not
            rare spikes; they are a design target. At the same time the total frame budget is 6.94&nbsp;ms if you want
            to hit 144&nbsp;FPS.
          </p>
          <p>
            This post digs into how the entity system is structured on top of <code>Flecs 4.x</code>, why it is wrapped
            in <code>phalnx::ecs::EntityManager</code> rather than exposed directly, and what that buys in terms of
            performance and failure modes. The pattern is the same one we use elsewhere: write down the rules
            first, then write the code that has a chance of obeying them.
          </p>

          <h3>Numbers first</h3>
          <p>
            It is easy to say “we want something fast and scalable” and then stop there. That kind of requirement
            is hard to falsify. Instead, for PHALANX the ECS layer writes down a tiny table of operation-level
            targets. If we drift far outside of these, something is wrong.
          </p>

          <figure>
            <figcaption><strong>Table&nbsp;1: ECS operation targets in PHALANX</strong></figcaption>
            <table>
              <thead>
              <tr>
                <th>Operation</th>
                <th>Target</th>
                <th>Critical</th>
              </tr>
              </thead>
              <tbody>
              <tr>
                <td>Entity creation (full component set)</td>
                <td>&lt; 150&nbsp;ns</td>
                <td>&gt; 200&nbsp;ns</td>
              </tr>
              <tr>
                <td><code>GetComponentMut</code> (in-place write)</td>
                <td>&lt; 25&nbsp;ns</td>
                <td>&gt; 50&nbsp;ns</td>
              </tr>
              <tr>
                <td><code>AddComponent</code> (archetype migration)</td>
                <td>&lt; 500&nbsp;ns</td>
                <td>&gt; 600&nbsp;ns</td>
              </tr>
              <tr>
                <td><code>RemoveComponent</code> (archetype migration)</td>
                <td>&lt; 550&nbsp;ns</td>
                <td>&gt; 650&nbsp;ns</td>
              </tr>
              <tr>
                <td><code>IsAlive()</code> liveness check</td>
                <td>&lt; 15&nbsp;ns</td>
                <td>&gt; 25&nbsp;ns</td>
              </tr>
              </tbody>
            </table>
          </figure>

          <p>
            These numbers come directly from the header comments in <code>entity_manager.h</code>. They are not
            promises about any possible hardware; they are expectations on the machines we care about.
          </p>
          <p>
            The point is that when we discuss a change we are not arguing about whether something “feels fast
            enough.” We are arguing about whether it keeps <code>AddComponent</code> under roughly half a microsecond
            and <code>GetComponentMut</code> under a couple of dozen nanoseconds. It also means that profiling “feels”
            less like vibes and more like regression detection.
          </p>

          <h3>Flecs under the hood, EntityManager in front</h3>
          <p>
            PHALANX uses <code>Flecs 4.x</code> as the core ECS runtime. Flecs stores entities with identical
            component signatures contiguously in archetype tables and gives you an API for querying and updating
            those tables. It also supplies a staging system and multi-threaded system execution.
          </p>
          <p>
            Gameplay code does not talk to the Flecs world directly. Instead it goes through a wrapper:
            <code>phalnx::ecs::EntityManager</code>. The motivation is not that the Flecs API is unsafe; the goal
            is to have a small, well-documented surface that encodes the way we are willing to use it.
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">entity_manager.h</p>
            <pre class="article-code-text cpp">using EntityID = flecs::entity_t;

enum class ECSError {
  EntityNotFound,
  ComponentMissing
};

class EntityManager {
public:
  template&lt;typename... Components&gt;
  [[nodiscard]] EntityID CreateEntity(Components&amp;&amp;... components);

  void DestroyEntity(EntityID id);
  [[nodiscard]] bool IsAlive(EntityID id) const;

  template&lt;typename T&gt;
  [[nodiscard]] const T* GetComponent(EntityID id) const;

  template&lt;typename T&gt;
  [[nodiscard]] T* GetComponentMut(EntityID id);

  template&lt;typename T&gt;
  [[nodiscard]] std::expected&lt;const T*, ECSError&gt;
    TryGetComponent(EntityID id) const;

  template&lt;typename T&gt;
  [[nodiscard]] std::expected&lt;T*, ECSError&gt;
    TryGetComponentMut(EntityID id);

  template&lt;typename T&gt;
  [[nodiscard]] bool HasComponent(EntityID id) const;

  template&lt;typename T&gt;
  void AddComponent(EntityID id, T&amp;&amp; component);

  template&lt;typename T&gt;
  void RemoveComponent(EntityID id);

  template&lt;typename... Components, typename Func&gt;
  void Query(Func&amp;&amp; callback) const;

  template&lt;typename... Components, typename Func&gt;
  void QueryMut(Func&amp;&amp; callback);

  void SetThreadCount(std::uint32_t thread_count);

  [[nodiscard]] flecs::world&amp;       GetWorld();
  [[nodiscard]] const flecs::world&amp; GetWorld() const;

  [[nodiscard]] StructuralChangeBatch BeginStructuralChangeBatch();

private:
  mutable flecs::world world_;
};</pre>
          </div>

          <p>
            All of the gameplay-facing ECS operations go through this class. Internally it constructs
            <code>flecs::entity</code> handles as needed and calls <code>set</code>, <code>add</code>, <code>remove</code>, <code>destruct</code>, and so on.
            Externally the rest of the codebase only needs to know about <code>EntityID</code> and these methods.
          </p>
          <p>
            That gives us a few things:
          </p>
          <ul>
            <li>A single place to attach documentation, invariants, and best practices.</li>
            <li>A seam where we can route allocations through custom allocators over time.</li>
            <li>A hook for Tracy profiling (<code>ENTITY_MANAGER_ZONE_SCOPED</code>) that does not pollute gameplay code.</li>
            <li>A way to adjust threading behavior or even swap out Flecs without rewriting every system.</li>
          </ul>
          <p>
            The wrapper is not there to make Flecs safer. It is there to make the way we use Flecs explicit and reviewable.
          </p>

          <h3>Components as plain old data</h3>
          <p>
            Components in PHALANX are deliberately uninteresting. They live in <code>phalnx::ecs</code> and they are
            required to be trivially copyable. The core set looks like this:
          </p>

          <div class="code-block">
<pre><code>struct Position  { float x, y, z; };
struct Velocity  { float x, y, z; };
struct Rotation  { float x, y, z, w; };

struct Health    { float current_hp, max_hp; };
struct Energy    { float current_energy, max_energy; };
struct Team      { std::uint32_t team_id; };

struct MechTag      {};
struct MinionTag    {};
struct ProjectileTag{};
struct StructureTag {};</code></pre>
          </div>

          <p>
            In the actual header these components have sensible default initializers, but the shape is exactly
            this.
          </p>
          <p>
            The header file <code>components.h</code> asserts that these are <code>std::is_trivially_copyable_v&lt;T&gt;</code>
            and that their sizes are exactly what we expect: <code>Position</code> and <code>Velocity</code> are 12&nbsp;bytes each,
            <code>Rotation</code> is 16, <code>Health</code> and <code>Energy</code> are 8, <code>Team</code> is 4, and the tag types are
            empty. There are also <code>static_assert</code> checks that the tag components are
            <code>std::is_empty_v&lt;T&gt;</code>.
          </p>
          <p>
            These constraints are not deep. They exist to prevent accidental
            padding and to keep common archetypes within predictable cache-line budgets. If we ever change a
            component in a way that bloats its size, the build fails loudly instead of quietly making iteration slower.
          </p>
          <p>
            On the side, there is a <code>ComponentRegistry</code> that records metadata for each type:
            a human-readable name, the size, the alignment, and whether it is a tag. This registry is a simple
            <code>std::unordered_map&lt;std::type_index, ComponentMetadata&gt;</code> and is used for logging, serialization,
            and tooling. The runtime ECS code does not depend on it; <code>EntityManager</code> does not know the
            registry exists, by design. That separation is intentional: the hot path does not pay for reflection,
            and the editor/debug path does not have to tunnel through the ECS wrapper to get type information.
          </p>

          <h3>Entity IDs and the habit of checking liveness</h3>
          <p>
            <code>EntityID</code> is an alias for <code>flecs::entity_t</code>, which is a 64-bit value containing both an
            index and a generation counter. When an entity is destroyed and its slot is reused, the generation
            changes. That solves the basic “stale ID accidentally refers to a new object” problem.
          </p>
          <p>
            The common liveness pattern looks like this:
          </p>

          <div class="code-block">
<pre><code>if (manager.IsAlive(target)) {
  if (auto* hp = manager.GetComponentMut&lt;Health&gt;(target)) {
    hp-&gt;current_hp -= 10.0f;
  }
}</code></pre>
          </div>

          <p>
            Internally <code>IsAlive</code> constructs a <code>flecs::entity</code> from the ID and calls
            <code>entity.is_alive()</code>. In debug builds there is also a <code>VALIDATE_ENTITY_ID</code> macro that
            prints a warning if you pass zero as an <code>EntityID</code>.
          </p>
          <p>
            The implementation is short and the cost is
            on the order of a few nanoseconds: a lookup followed by a bitset check in Flecs. That is cheap enough
            that you can afford to be conservative.
          </p>
          <p>
            The pattern we want here is similar to the one in the spinlock example where you use <code>READ_ONCE</code>
            at the right points. Whenever code captures an <code>EntityID</code> and uses it later—after one or more
            frames, after network round-trips, after deferred execution—it should guard uses with
            <code>IsAlive</code>. That does not prevent races, but it does stop the most direct use-after-destroy bugs.
          </p>

          <div class="code-block">
<pre><code>void ScheduledDamage(EntityID target) {
  scheduler.ScheduleEvent(1.0f, [&, target]() {
    if (!manager.IsAlive(target)) return;

    if (auto* health = manager.GetComponentMut&lt;Health&gt;(target)) {
      health-&gt;current_hp -= 10.0f;
    }
  });
}</code></pre>
          </div>

          <p>
            The important bit is not that <code>IsAlive</code> is novel. It is that we treat "always guard delayed uses
            with <code>IsAlive</code>" as a rule, not as a suggestion. That consistency is what keeps the failure modes boring.
          </p>

          <h3>Structural changes and batches</h3>
          <p>
            The pleasant part of an archetype ECS is iterating over tight arrays of components. The less pleasant
            part is changing which components an entity has. Adding a component moves the entity to a new table.
            Removing a component does the same. In both cases all pointers to that entity’s components become
            invalid, including pointers to components you did not explicitly change.
          </p>
          <p>
            The <code>EntityManager</code> interface exposes this through <code>AddComponent</code>,
            <code>RemoveComponent</code>, and <code>DestroyEntity</code>. The comments on these functions are blunt about
            pointer invalidation, and they include minimal examples of what goes wrong if you ignore that fact.
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">structural_changes.cpp</p>
            <pre class="article-code-text cpp">// Danger: AddComponent invalidates all component pointers.
Position* pos = manager.GetComponentMut&lt;Position&gt;(entity);
pos-&gt;x = 10.0f;
manager.AddComponent(entity, Energy{100.0f, 100.0f}); // archetype migration
pos-&gt;y = 20.0f; // undefined behavior: pos is now dangling</pre>
          </div>

          <p>
            The safe pattern for single entities is to re-query after a structural change:
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">structural_changes.cpp</p>
            <pre class="article-code-text cpp">Position* pos = manager.GetComponentMut&lt;Position&gt;(entity);
pos-&gt;x = 10.0f;
manager.AddComponent(entity, Energy{100.0f, 100.0f});
pos = manager.GetComponentMut&lt;Position&gt;(entity); // fresh pointer
pos-&gt;y = 20.0f;</pre>
          </div>

          <p>
            For bulk changes there is a separate tool: <code>StructuralChangeBatch</code>. This is a small RAII
            wrapper that calls <code>world.defer_begin()</code> in its constructor and <code>world.defer_end()</code> in its
            destructor. While it is alive, Flecs queues structural changes in a per-thread staging area. When it
            ends, those queued operations are applied.
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">structural_changes.cpp</p>
            <pre class="article-code-text cpp">auto batch = manager.BeginStructuralChangeBatch();

for (int i = 0; i &lt; 1000; ++i) {
  EntityID id = manager.CreateEntity();
  batch.AddComponent(id, Position{float(i), 0.0f, 0.0f});
  batch.AddComponent(id, Health{100.0f, 100.0f});
} // destructor calls defer_end(), applying queued changes</pre>
          </div>

          <p>
            From the code’s point of view this gives two properties:
          </p>
          <ul>
            <li>It provides an all-or-nothing boundary: either all of these structural changes become visible together or none of them do.</li>
            <li>It reduces the number of places where pointer invalidation can occur. Pointers remain valid within the batch scope; they are invalidated when the batch flushes.</li>
          </ul>
          <p>
            The batch class also has an <code>Apply</code> method that explicitly calls <code>defer_end</code> and then
            <code>defer_begin</code> again. This lets you flush mid-batch for debugging or profiling and then keep
            queuing more operations within the same scope.
          </p>
          <p>
            The important detail is that batching is there primarily for transaction-like semantics and for
            controlling when pointers go stale. You still pay for structural changes when the batch flushes. The
            mental model should be “group these changes and make them appear all at once,” not “structural
            changes are free now.”
          </p>
          <p>
            In practice, staying within the per-operation budgets
            from Table&nbsp;1 while using batches for bulk spawns or mass cleanup gives you both better behavior and,
            for large operations, a noticeable speedup. The code is also easier to reason about: the places where
            pointers become invalid are spelled out by scope.
          </p>

          <h3>Queries as the iteration primitive</h3>
          <p>
            Most systems do not care about entity creation or destruction; they care about iterating over
            entities that have certain components. The <code>EntityManager</code> exposes this via two templates:
            <code>Query</code> for read-only access and <code>QueryMut</code> for mutable access.
          </p>

          <div class="article-code draw-left-line">
            <p class="article-code-file mark-section">queries.cpp</p>
            <pre class="article-code-text cpp">manager.Query&lt;Position, const Velocity&gt;(
  [](EntityID id, const Position&amp; pos, const Velocity&amp; vel) {
    // read-only path
  });

float dt = 0.016f;
manager.QueryMut&lt;Position, const Velocity&gt;(
  [dt](EntityID id, Position&amp; pos, const Velocity&amp; vel) {
    pos.x += vel.x * dt;
    pos.y += vel.y * dt;
    pos.z += vel.z * dt;
  });</pre>
          </div>

          <p>
            Under the hood both forms construct a Flecs query and call <code>.each</code> with a lambda that
            receives a <code>flecs::entity</code> and component references. The wrapper converts
            <code>entity.id()</code> to an <code>EntityID</code> and forwards the component references.
          </p>
          <p>
            The const vs
            mutable distinction is enforced at the type level, so if you pick <code>Query</code> you cannot
            accidentally mutate components. Both methods also wrap the iteration in a Tracy profiler zone via
            <code>ENTITY_MANAGER_ZONE_SCOPED</code>, so query cost shows up cleanly in profiles.
          </p>
          <p>
            The performance target for these iterations is on the order of 50&nbsp;ns per entity for common
            queries, which keeps a 20k-entity pass under roughly one millisecond. Archetype storage gives the
            usual benefit: entities with the same component sets are adjacent in memory, and the queries walk
            that memory linearly.
          </p>
          <p>
            From a design point of view, this is also the point where we stop pretending entities are objects.
            Systems express "all entities with (Position, Velocity)" as a single pass, and the ECS layer makes that
            pattern cheap enough to use everywhere.
          </p>

          <h3>Threading: configuring Flecs, not replacing it</h3>
          <p>
            For threading, the wrapper provides a <code>SetThreadCount</code> method that calls
            <code>world.set_threads</code> on the underlying Flecs world. Systems are then registered directly on
            that world.
          </p>

          <div class="code-block">
<pre><code>EntityManager manager;
manager.SetThreadCount(13); // example on a 16-core machine

auto&amp; world = manager.GetWorld();

world.system&lt;Position, const Velocity&gt;("ProjectilePhysics")
  .multi_threaded()
  .each([](flecs::entity e, Position&amp; pos, const Velocity&amp; vel) {
    pos.x += vel.x * dt;
    pos.y += vel.y * dt;
    pos.z += vel.z * dt;
  });</code></pre>
          </div>

          <p>
            The recommended pattern is straightforward:
          </p>
          <ul>
            <li>Configure the thread count once at initialization, before the main loop.</li>
            <li>Register systems on the main thread before the first call to <code>world.progress()</code>.</li>
            <li>Mark systems that can safely run in parallel with <code>.multi_threaded()</code>.</li>
            <li>Let Flecs handle slicing entity sets across worker threads for those systems.</li>
          </ul>
          <p>
            Structural changes that occur inside multi-threaded systems are automatically deferred to per-thread
            stages and merged at synchronization points when the world progresses. Reads of components are safe
            across threads during that window; writes are safe as long as each entity is only processed by one
            thread (which is exactly what Flecs arranges for these systems).
          </p>
          <p>
            The wrapper does not try to replace Flecs' threading model. It just gives us a predictable place to
            turn the dial and a documented set of constraints around it.
          </p>

          <h3>Error handling: null pointers and expected errors</h3>
          <p>
            The basic component accessors return either a pointer to the component or <code>nullptr</code>:
          </p>

          <div class="code-block">
<pre><code>if (auto* pos = manager.GetComponentMut&lt;Position&gt;(id)) {
  pos-&gt;x += 1.0f;
}</code></pre>
          </div>

          <p>
            This is the cheap, hot path. It is good enough for most gameplay systems: either the component is
            there, or it is not, and "missing" is a normal condition.
          </p>
          <p>
            For situations where it matters why a lookup failed there are the <code>TryGetComponent</code> and
            <code>TryGetComponentMut</code> variants, which wrap the pointer in <code>std::expected</code> and tag
            failures with <code>ECSError::EntityNotFound</code> or <code>ECSError::ComponentMissing</code>.
          </p>

          <div class="code-block">
<pre><code>enum class ECSError {
  EntityNotFound,
  ComponentMissing
};

auto result = manager.TryGetComponentMut&lt;Health&gt;(id);
if (!result) {
  if (result.error() == ECSError::EntityNotFound) {
    // entity is gone
  } else {
    // entity exists but lacks Health
  }
} else {
  result.value()-&gt;current_hp -= 25.0f;
}</code></pre>
          </div>

          <p>
            Mechanically this is just a thin layer over the same logic, but it gives code that cares about
            diagnostics a clearer path. A replay system can distinguish "this entity died" from "this entity
            never had that component." A debugging tool can log more precise messages instead of guessing.
          </p>
          <p>
            Most code paths do not need this level of detail and use the pointer-returning forms. The important
            bit is that the structured version exists and is spelled out in the API, not buried under
            <code>dynamic_cast</code> or exception handling.
          </p>

          <h3>Oh yeah: here is a T1 turret render</h3>
          <p>
            All of this is fairly abstract. It is about archetypes, liveness checks, and avoiding use-after-free
            bugs. To make things more concrete, here is one of the assets this machinery exists to support: a
            render of our Tier&nbsp;1 outer turret design for PHALANX.
          </p>
          <p>
            When the entity system behaves, you can have scenes full of objects like this—tracking targets,
            taking damage, respawning—without the simulation becoming the bottleneck. The ECS layer is there
            partly so we can afford to have many of these doing useful work at once, without guessing where the
            time went or why a pointer suddenly went stale.
          </p>
          <p>
            The rules are simple: keep components as POD, guard delayed uses with <code>IsAlive</code>, respect
            pointer invalidation on structural changes, and run everything through a thin wrapper that is honest
            about performance and failure modes. The rest—90k entities, 144&nbsp;FPS, and a field of active
            turrets—is just what happens when those rules are obeyed consistently.
          </p>

          <figure>
            <img src="t1-outer-tower-v2-final-Rendered.png"
                 alt="Render of the Tier 1 outer turret design for PHALANX"
                 style="max-width: 100%; height: auto; border-radius: 4px;">
          </figure>
        </div>
      </article>
    </section>
  </div>
</main>

<footer>
  <div class="container">
    <p>
      <a href="https://github.com/N0V4-Labs" style="color: var(--link-color); text-decoration: none;">github</a>
      &nbsp;•&nbsp;
      <a href="about.html" style="color: var(--link-color); text-decoration: none;">about</a>
    </p>
  </div>
</footer>
</body>
</html>
